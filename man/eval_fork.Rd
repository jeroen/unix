% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fork.R
\name{eval_fork}
\alias{eval_fork}
\alias{eval_safe}
\title{Safe Evaluation}
\usage{
eval_fork(expr, tmp = tempfile("fork"), timeout = 60, std_out = stdout(),
  std_err = stderr())

eval_safe(expr, tmp = tempfile("fork"), timeout = 60, std_out = stdout(),
  std_err = stderr(), device = pdf, rlimits = list(), uid = NULL,
  gid = NULL, priority = NULL, profile = NULL)
}
\arguments{
\item{expr}{expression to evaluate}

\item{tmp}{the value of \code{\link[=tempdir]{tempdir()}} inside the forked process}

\item{timeout}{maximum time in seconds to allow for call to return}

\item{std_out}{if and where to direct child process \code{STDOUT}. Must be one of
\code{TRUE}, \code{FALSE}, filename, connection object or callback function. See also \code{\link[sys:exec_wait]{sys::exec_wait()}}.}

\item{std_err}{if and where to direct child process \code{STDERR}. Must be one of
\code{TRUE}, \code{FALSE}, filename, connection object or callback function. See also \code{\link[sys:exec_wait]{sys::exec_wait()}}.}

\item{device}{graphics device to use in the fork, see \code{\link[=dev.new]{dev.new()}}}

\item{rlimits}{named list of \link{rlimit} values, for example: \code{list(cpu = 60, fsize = 1e6)}.}

\item{uid}{evaluate as given user (uid or name). See \code{\link[=setuid]{setuid()}}, only for root.}

\item{gid}{evaluate as given group (gid or name). See \code{\link[=setgid]{setgid()}} only for root.}

\item{priority}{process priority, see \code{\link[=setpriority]{setpriority()}}.}

\item{profile}{AppArmor profile, see \code{RAppArmor::aa_change_profile()}.
Requires the \code{RAppArmor} package (Debian/Ubuntu only)}
}
\description{
Evaluates an expression in a temporary fork so that it has no side effects on the main R session.
For \code{\link[=eval_safe]{eval_safe()}} the expression is wrapped in additional R code to set \link[=rlimit]{rlimits}, catch
errors, close graphics devices, etc (recommended).
}
\examples{
# works like regular eval:
eval_safe(rnorm(5))

# Exceptions get propagated
test <- function() { doesnotexit() }
tryCatch(eval_safe(test()), error = function(e){
  cat("oh no!", e$message, "\\n")
})

# Honor interrupt and timeout, even inside C evaluations
try(eval_safe(svd(matrix(rnorm(1e8), 1e4)), timeout = 2))

# Capture output
outcon <- rawConnection(raw(0), "r+")
eval_safe(print(sessionInfo()), std_out = outcon)
cat(rawToChar(rawConnectionValue(outcon)))
}
